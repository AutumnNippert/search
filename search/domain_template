// Here is the class template for creating a new domain.
// Search algorithms are templatized on domains that
// must look like this.

#include "../utils/utils.hpp"
#include <cstdio>

struct <DOMAIN> {

	// Probably double, float, or int.  Must be convertable
	// to a double, must be constructable from an int.
	// Cost(-1) is reserved for infinite cost.  See gridnav
	// for an example of a kind of sophistocated cost type.
	// 
	// Some searches will use a special (faster)
	// closed list if the costs are ints.
	typedef <COST> Cost;

	// The type of an operator which can be
	// applied to a state.  This is usually just an
	// integer but it may be some more complex
	// class.  Searches assume that operator==
	// is defined on the Oper class.
	typedef <OPER> Oper;
	static const <OPER> Nop = …;

	<DOMAIN>(FILE*);

	struct State {	…	};

	// Memory-intensive algs such as A* which store
	// PackedStates instead of States.  Each time operations	
	// are needed, the state is unpacked and operated
	// upon.
	//
	// If your state is as packed as it will get then you
	// can simply 'typedef State PackedState'
	struct PackedState {
		…

		// Functions for putting a packed state
		// into a hash table.
		unsigned long hash(void) { return -1; }
		bool eq(PackedState &) const { return false; }
	};

	// Get the initial state.
	State initialstate(void);

	// Get the heuristic.
	Cost h(State &s) {
		fatal("Unimplemented");
		return 0.0;
	}

	// Get a distance estimate.
	Cost d(State &s) {
		fatal("Unimplemented");
		return 0.0;
	}

	// Is the given state a goal state?
	bool isgoal(State &s) {
		fatal("Unimplemented");
		return false;
	}

	// Get the number of operators that are
	// applicable in the state.
	//
	// Some domains may need to compute the
	// operators for a state.  A nice trick seems
	// to be to compute the operators in nops
	// and cache the result in the state.
	//
	// Because of the above trick, a search algorithm
	// should compute nops() after each time a
	// new state is unpacked.  Do not cache this
	// value.
	unsigned int nops(State &s) {
		fatal("Unimplemented");
		return 0;
	}

	// Get the nth operator.  This should always be
	// called after a call to nops on the given state.
	Oper nthop(State &s, unsigned int n) {
		fatal("Unimplemented");
		return 0;
	}

	struct Transition {
		Cost cost;
		Oper revop;

		// The state field may or may not be a reference.
		// The reference variant is used in domains that
		// do in-place modification and the non-reference
		// variant is used in domains that do out-of-place
		// modification.
		State state;
		// State &state

		// Applys the operator to thet state.  Some domains
		// may modify the input state in this constructor.
		// Because of this, a search algorithm may not
		// use the state passed to this constructor until
		// after the Transition's destructor has been called!
		Transition(DOMAIN&, State&, Oper) { }

		// The destructor is expected to undo any changes
		// that it may have made to the input state in
		// the constructor.  If a domain uses out-of-place
		// modification then the destructor may not be
		// required.
		~Transition(void) { }
	};

	// Pack the state into the destination packed state.
	// If PackedState is the same type as State then this
	// should at least copy.
	void pack(PackedState &dst, State &src) {
		fatal("Unimplemented");
	}

	// Unpack the state and return a reference to the
	// resulting unpacked state.  If PackedState and
	// State are the same type then the packed state
	// can just be immediately returned and used
	// so that there is no need to copy.
	State &unpack(State &buf, PackedState &pkd) {
		fatal("Unimplemented");
		return buf;
	}

	// Print the state.
	void dumpstate(FILE *out, State &s) {
		fatal("Unimplemented");
	}
};