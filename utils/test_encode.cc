// Â© 2013 the Search Authors under the MIT license. See AUTHORS for the list of authors.

#include "utils.hpp"

static const struct { const char *str, *enc; } base64tst[] = {
	{ "\xfa", "+g==" },
	{ "\xfa\x06", "+gY=" },
	{ "\xfa\x06\xf7", "+gb3" },
	{ "\xfa\x06\xf7\x04", "+gb3BA==" },
	{ "Man", "TWFu" },
	{ "pleasure.", "cGxlYXN1cmUu" },
	{ "leasure.", "bGVhc3VyZS4=" },
	{ "easure.", "ZWFzdXJlLg==" },
	{ "asure.", "YXN1cmUu" },
	{ "sure.", "c3VyZS4=" },
	{ "Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.",
	"TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=" },
};

bool test_base64enc() {

	bool ok = true;
	for (unsigned int i = 0; i < sizeof(base64tst) / sizeof(base64tst[0]); i++) {
		std::string enc = base64enc(base64tst[i].str);
		if (enc == base64tst[i].enc)
			continue;
		testpr("Failed to correctly encode [%s], expected [%s], got [%s]\n",
			base64tst[i].str, base64tst[i].enc, enc.c_str());
		ok = false;
	}

	return ok;
}

bool test_base64dec() {

	bool ok = true;
	for (unsigned int i = 0; i < sizeof(base64tst) / sizeof(base64tst[0]); i++) {
		std::string str = base64dec(base64tst[i].enc);
		if (str == base64tst[i].str)
			continue;
		testpr("Failed to correctly decode [%s], expected [%s], got [%s]\n",
			base64tst[i].enc, base64tst[i].str, str.c_str());
		ok = false;
	}

	return ok;
}

// This test was known to fail at one point.
bool test_encdec() {
	const char bytes[] = { 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x5, 0x6, 0x5, 0x6, 0x6, 0x6, 0x6, 0x4, 0x4, 0x4, 0x4, 0x4, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x6, 0x6, 0x6, 0x5, 0x6, 0x5, 0x6, 0x2, 0x5, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x6, 0x5, 0x5, 0x5, 0x5, 0x6, 0x6, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x6, 0x6, 0x5, 0x6, 0x5, 0x6, 0x5, 0x2, 0x5, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x6, 0x5, 0x6, 0x5, 0x6, 0x5, 0x6, 0x1, 0x1, 0x1, 0x6, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x6, 0x6, 0x5, 0x6, 0x5, 0x6, 0x5, 0x4, 0x4, 0x4, 0x4, 0x2, 0x5, 0x4, 0x4, 0x4, 0x4, 0x4, 0x6, 0x5, 0x6, 0x5, 0x6, 0x5, 0x6, 0x1, 0x4, 0x4, 0x4, 0x4, 0x1, 0x1, 0x4, 0x4, 0x4, 0x4, 0x5, 0x6, 0x5, 0x6, 0x5, 0x6, 0x6, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x6, 0x6, 0x5, 0x6, 0x5, 0x6, 0x5, 0x2, 0x5, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x6, 0x5, 0x6, 0x5, 0x6, 0x5, 0x6, 0x1, 0x1, 0x1, 0x6, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x6, 0x6, 0x6, 0x5, 0x6, 0x5, 0x6, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x0 };

	std::string rl = runlenenc(bytes);
	if (runlendec(rl) != bytes) {
		testpr("Run-length failed to decode\n");
		return false;
	}

	std::string base64 = base64enc(rl);
	std::string dec = base64dec(base64);
	if (dec != rl) {
		testpr("Base64 failed to decode\n");
		testpr("base64=[%s]\n", base64.c_str());
		testpr("rl=[");
		for (unsigned int i = 0; i < rl.size(); i++) {
			if (i > 0)
				testpr(", ");
			testpr("%#x", rl[i]);
		}
		testpr("]\n");
		testpr("dec=[");
		for (unsigned int i = 0; i < rl.size(); i++) {
			if (i > 0)
				testpr(", ");
			testpr("%#x", dec[i]);
		}
		testpr("]\n");
		return false;
	}

	return true;
}